# ðŸ§  AgentFlow â€” The Lovable for AI Agents

> **"Type what you want automated. We build and run it."**

---

## 1. Vision

AgentFlow is a platform where users describe automations in plain English. Behind the scenes, two AI agents decompose the request into composable **Blocks**, wire them into a **Pipeline**, and execute â€” creating new Blocks on-the-fly when none exist.

```
User: "Order lunch every weekday under â‚¬15 â€” surprise me"
                    â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   ORCHESTRA AGENT   â”‚  â† Understands goal, finds/connects blocks
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†“
    â”Œâ”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”
    â”‚CRONâ”‚â†’ â”‚FOOD APIâ”‚â†’ â”‚CLAUDE â”‚â†’ â”‚PAYMENT â”‚â†’ â”‚NOTIFYâ”‚
    â”‚TRIGâ”‚  â”‚ SEARCH â”‚  â”‚DECIDE â”‚  â”‚ STRIPE â”‚  â”‚ TTS  â”‚
    â””â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜
                 â†‘
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   BUILDER AGENT     â”‚  â† Creates missing blocks on demand
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Core Architecture

### 2.1 Two-Agent System

| Agent | Role | Knows | Doesn't Know |
|-------|------|-------|--------------|
| **Orchestra** | Decomposes user goal â†’ finds blocks â†’ connects them â†’ executes pipeline | Block registry (name, description, input schema, output schema) | Internal implementation of any block |
| **Builder** | Creates new blocks when Orchestra can't find a match | Available APIs, code templates, how to write execution code | The user's original goal (only gets a block spec from Orchestra) |

### 2.2 The Block Model

A Block is a **black box** with a defined contract:

```json
{
  "id": "food_search_nearby",
  "name": "Search Nearby Restaurants",
  "description": "Searches food delivery APIs for restaurants near a location, filtered by cuisine and budget",
  "version": "1.0.0",
  "category": "food",

  "input_schema": {
    "type": "object",
    "properties": {
      "location": { "type": "string", "description": "Address or lat/lng" },
      "max_price": { "type": "number", "description": "Max price in EUR" },
      "cuisine": { "type": "string", "description": "Optional cuisine preference" }
    },
    "required": ["location"]
  },

  "output_schema": {
    "type": "object",
    "properties": {
      "restaurants": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "name": { "type": "string" },
            "menu_items": { "type": "array" },
            "price_range": { "type": "string" },
            "rating": { "type": "number" },
            "delivery_time_min": { "type": "number" }
          }
        }
      }
    }
  },

  "execution": {
    "runtime": "python",
    "entrypoint": "blocks/food_search_nearby/main.py",
    "function": "execute"
  },

  "metadata": {
    "created_by": "builder_agent",
    "created_at": "2025-02-21T10:00:00Z",
    "apis_used": ["deliveroo", "uber_eats"],
    "avg_latency_ms": 1200
  }
}
```

### 2.3 Pipeline Model

Orchestra creates a **DAG** (Directed Acyclic Graph) of connected blocks:

```json
{
  "id": "pipeline_daily_lunch",
  "name": "Daily Surprise Lunch",
  "user_prompt": "Order lunch every weekday under â‚¬15 â€” surprise me",

  "trigger": {
    "type": "cron",
    "schedule": "30 11 * * 1-5",
    "timezone": "Europe/Dublin"
  },

  "nodes": [
    {
      "id": "n1",
      "block_id": "food_search_nearby",
      "inputs": {
        "location": "{{user.address}}",
        "max_price": 15,
        "cuisine": null
      }
    },
    {
      "id": "n2",
      "block_id": "claude_decide",
      "inputs": {
        "options": "{{n1.restaurants}}",
        "criteria": "Pick something new â€” avoid: {{memory.past_orders}}. Prioritize variety and good ratings.",
        "memory_context": "{{memory.food_preferences}}"
      }
    },
    {
      "id": "n3",
      "block_id": "payment_stripe",
      "inputs": {
        "amount": "{{n2.selected_item.price}}",
        "currency": "EUR",
        "description": "Lunch: {{n2.selected_item.name}}"
      }
    },
    {
      "id": "n4",
      "block_id": "food_order_place",
      "inputs": {
        "restaurant_id": "{{n2.selected_item.restaurant_id}}",
        "item_id": "{{n2.selected_item.id}}",
        "delivery_address": "{{user.address}}"
      }
    },
    {
      "id": "n5",
      "block_id": "notify_tts",
      "inputs": {
        "message": "I ordered you {{n2.selected_item.name}} from {{n2.selected_item.restaurant}}. Arrives by {{n4.estimated_delivery}}."
      }
    }
  ],

  "edges": [
    { "from": "n1", "to": "n2" },
    { "from": "n2", "to": "n3" },
    { "from": "n3", "to": "n4" },
    { "from": "n4", "to": "n5" }
  ],

  "memory_keys": ["past_orders", "food_preferences", "ratings"],

  "error_handling": {
    "on_block_failure": "notify_user_and_halt",
    "retry_count": 2
  }
}
```

---

## 3. How It Works â€” End to End

### 3.1 User Flow

```
1. User visits website
2. Types: "Monitor Amazon for PS5 price drops below â‚¬400 and buy it"
3. Orchestra Agent:
   a. Parses intent â†’ identifies needed capabilities
   b. Searches Block Registry for matching blocks
   c. If block missing â†’ requests Builder Agent to create it
   d. Connects blocks into a Pipeline (DAG)
   e. Presents plan to user for approval
   f. On approval â†’ deploys pipeline
4. Pipeline runs on trigger (every 6 hours)
5. User gets notified of results
```

### 3.2 Orchestra Agent â€” Detailed Flow

```
INPUT: User's natural language request
  â”‚
  â”œâ”€ STEP 1: DECOMPOSE
  â”‚   Claude analyzes the request and produces a list of required capabilities:
  â”‚   - "I need: price checking, threshold comparison, payment, notification"
  â”‚
  â”œâ”€ STEP 2: MATCH BLOCKS
  â”‚   Search block registry by capability description
  â”‚   For each capability:
  â”‚     â†’ FOUND: add block to pipeline plan
  â”‚     â†’ NOT FOUND: send spec to Builder Agent, wait for new block
  â”‚
  â”œâ”€ STEP 3: CONNECT
  â”‚   Wire block outputs â†’ inputs using the schema
  â”‚   Resolve {{template}} references
  â”‚   Identify trigger type (cron, webhook, manual, event)
  â”‚
  â”œâ”€ STEP 4: VALIDATE
  â”‚   Check all input schemas are satisfied
  â”‚   Check no dangling outputs
  â”‚   Check trigger is configured
  â”‚
  â”œâ”€ STEP 5: PRESENT
  â”‚   Show user: "Here's my plan: [visual pipeline]. Approve?"
  â”‚
  â””â”€ STEP 6: DEPLOY
      Save pipeline, register trigger, start execution
```

### 3.3 Builder Agent â€” Detailed Flow

```
INPUT: Block specification from Orchestra
  {
    "name": "amazon_price_check",
    "description": "Check current price of a product on Amazon given a URL",
    "input_schema": { "product_url": "string" },
    "output_schema": { "price": "number", "currency": "string", "in_stock": "boolean" }
  }
  â”‚
  â”œâ”€ STEP 1: SELECT API/METHOD
  â”‚   Check available APIs list
  â”‚   Choose: web scraping, official API, or hybrid
  â”‚
  â”œâ”€ STEP 2: GENERATE CODE
  â”‚   Write Python function matching the block contract:
  â”‚
  â”‚   async def execute(inputs: dict) -> dict:
  â”‚       url = inputs["product_url"]
  â”‚       # ... scrape/API logic ...
  â”‚       return {"price": 389.99, "currency": "EUR", "in_stock": True}
  â”‚
  â”œâ”€ STEP 3: TEST
  â”‚   Run with sample inputs, verify output matches schema
  â”‚
  â””â”€ STEP 4: REGISTER
      Save to block registry, notify Orchestra
```

---

## 4. Block Registry â€” Starter Kit

These are the **pre-built blocks** we ship with. Orchestra can use these immediately.

### 4.1 Trigger Blocks

| Block ID | Description | Output |
|----------|-------------|--------|
| `trigger_cron` | Fires on a cron schedule | `{ "triggered_at": "datetime" }` |
| `trigger_webhook` | Fires on incoming HTTP request | `{ "payload": "any", "headers": "object" }` |
| `trigger_user_event` | Fires on user action (photo, message, etc.) | `{ "event_type": "string", "data": "any" }` |
| `trigger_manual` | One-time user request | `{ "user_input": "string" }` |

### 4.2 Input/Data Blocks

| Block ID | Description | Input â†’ Output |
|----------|-------------|----------------|
| `web_scrape` | Scrape a URL, extract structured data | `{url, selectors}` â†’ `{data}` |
| `web_search` | Search the web for information | `{query, num_results}` â†’ `{results[]}` |
| `api_call` | Generic HTTP API call | `{url, method, headers, body}` â†’ `{response}` |
| `image_analyze` | Analyze image with vision model | `{image_url, prompt}` â†’ `{analysis}` |
| `youtube_fetch` | Get video details/transcript | `{channel_ids or video_url}` â†’ `{videos[]}` |

### 4.3 Processing Blocks

| Block ID | Description | Input â†’ Output |
|----------|-------------|----------------|
| `claude_decide` | Claude makes a decision from options | `{options, criteria, context}` â†’ `{selected, reasoning}` |
| `claude_summarize` | Claude summarizes content | `{content, style, max_length}` â†’ `{summary}` |
| `claude_analyze` | Claude analyzes/compares data | `{data, analysis_type}` â†’ `{analysis, score}` |
| `claude_generate` | Claude generates content | `{prompt, format}` â†’ `{content}` |
| `filter_threshold` | Compare value against threshold | `{value, operator, threshold}` â†’ `{passed: bool, value}` |
| `data_transform` | Transform/reshape data | `{data, mapping}` â†’ `{transformed}` |
| `conditional_branch` | If/else routing | `{condition, data}` â†’ routes to different next blocks |

### 4.4 Action Blocks

| Block ID | Description | Input â†’ Output |
|----------|-------------|----------------|
| `payment_stripe` | Process payment via Stripe | `{amount, currency, desc}` â†’ `{payment_id, status}` |
| `email_send` | Send email | `{to, subject, body}` â†’ `{sent: bool}` |
| `notify_tts` | Text-to-speech notification (ElevenLabs) | `{message, voice}` â†’ `{audio_url}` |
| `notify_push` | Push notification | `{title, body}` â†’ `{delivered: bool}` |
| `file_save` | Save data to storage | `{key, data}` â†’ `{saved: bool}` |

### 4.5 Memory Blocks

| Block ID | Description | Input â†’ Output |
|----------|-------------|----------------|
| `memory_read` | Read from user's memory store | `{key}` â†’ `{value}` |
| `memory_write` | Write to user's memory store | `{key, value}` â†’ `{success: bool}` |
| `memory_append` | Append to a list in memory | `{key, item}` â†’ `{list_length}` |
| `memory_search` | Semantic search over memory | `{query}` â†’ `{results[]}` |

---

## 5. Available APIs (for Builder Agent)

When Builder needs to create a new block, it can use any of these:

```yaml
APIs Available:
  # Search & Web
  - serper_api:     Web search (Google results)
  - firecrawl:      Web scraping & crawling
  - browserless:    Headless browser for JS-heavy sites

  # AI & ML
  - anthropic:      Claude API (reasoning, analysis, generation)
  - openai:         GPT + DALL-E + Whisper
  - google_gemini:  Vision, multimodal analysis
  - elevenlabs:     Text-to-speech

  # Commerce & Payments
  - stripe:         Payments, subscriptions
  - amazon_pa_api:  Amazon product data (if available)

  # Communication
  - sendgrid:       Email
  - twilio:         SMS, voice calls
  - slack_api:      Slack messages

  # Data & Storage
  - supabase:       PostgreSQL database + auth
  - redis:          Key-value cache / pub-sub
  - s3:             File storage

  # Social & Media
  - twitter_api:    Posts, search, sentiment
  - youtube_api:    Channel/video data
  - spotify_api:    Music data

  # Travel & Food
  - skyscanner:     Flight search
  - google_maps:    Location, directions
  - deliveroo_api:  Food delivery (if available)

  # Scheduling
  - google_calendar: Calendar events
  - cron_service:    Scheduled triggers
```

---

## 6. Hackathon MVP â€” What to Build First

### 6.1 Priority Stack (Build in Order)

```
HOUR 1-2: Foundation
â”œâ”€â”€ Block Registry (JSON file / SQLite)
â”œâ”€â”€ Block execution runtime (Python async functions)
â”œâ”€â”€ 5 hardcoded starter blocks (web_search, claude_decide, notify, memory_read, memory_write)
â””â”€â”€ Simple pipeline executor (sequential)

HOUR 3-4: The Agents
â”œâ”€â”€ Orchestra Agent (Claude API call with block registry as context)
â”‚   â”œâ”€â”€ System prompt with registry + pipeline format
â”‚   â”œâ”€â”€ Decompose â†’ Match â†’ Connect flow
â”‚   â””â”€â”€ Output: pipeline JSON
â”œâ”€â”€ Builder Agent (Claude API call with API list as context)
â”‚   â”œâ”€â”€ System prompt with API docs + block template
â”‚   â”œâ”€â”€ Generate â†’ Test â†’ Register flow
â”‚   â””â”€â”€ Output: new block code + schema
â””â”€â”€ Connect Orchestra â†” Builder (when block not found)

HOUR 5-6: Frontend
â”œâ”€â”€ Single page: text input + pipeline visualizer
â”œâ”€â”€ Show: "Here's my plan" â†’ block diagram
â”œâ”€â”€ Approve button â†’ execute
â””â”€â”€ Results display

HOUR 7-8: Polish & Demo
â”œâ”€â”€ 3 working demo scenarios end-to-end
â”œâ”€â”€ Pretty pipeline visualization (Mermaid or React Flow)
â”œâ”€â”€ Error handling
â””â”€â”€ Demo script
```

### 6.2 MVP Demo Scenarios

**Demo 1: "Track Bitcoin price and tell me if it drops below $60k"** (simplest â€” cron + scrape + threshold + notify)

**Demo 2: "Summarize the top 3 Hacker News posts every morning"** (search + fetch + summarize + notify)

**Demo 3: "Watch competitor.com/pricing and alert me if anything changes"** (scrape + diff + conditional + notify â€” shows Builder creating the diff block)

### 6.3 What to SKIP for Hackathon

- Real payments (mock Stripe)
- Real delivery APIs (mock the response)
- User auth (hardcode one user)
- Persistent scheduling (use simple setInterval or manual trigger)
- Production error handling
- Block versioning
- Multi-user

---

## 7. Tech Stack

```
Frontend:     Next.js (or plain React) + Tailwind
              React Flow for pipeline visualization
Backend:      FastAPI (Python)
AI:           Claude API (Anthropic) for both agents
Database:     SQLite (hackathon) â†’ Supabase (production)
Block Runtime: Python async functions
Triggers:     APScheduler (hackathon) â†’ proper job queue later
Storage:      Local filesystem â†’ S3
```

---

## 8. Key System Prompts

### 8.1 Orchestra Agent System Prompt

```markdown
You are the Orchestra Agent. Your job is to take a user's automation request
and decompose it into a pipeline of Blocks.

## Available Blocks
{{BLOCK_REGISTRY}}

## Your Process
1. UNDERSTAND the user's goal completely
2. DECOMPOSE into discrete steps (what needs to happen, in what order)
3. MATCH each step to an available block
4. If NO block exists for a step, output a BLOCK_REQUEST with:
   - name, description, input_schema, output_schema
5. CONNECT blocks by mapping outputs â†’ inputs using {{node_id.field}} syntax
6. IDENTIFY the trigger type (cron, webhook, manual, event)
7. Output a complete pipeline JSON

## Rules
- You ONLY know blocks by their input/output schemas. Never assume internal behavior.
- Always check if a block exists before requesting a new one.
- Keep pipelines as SHORT as possible. Don't over-engineer.
- For decisions, preferences, or reasoning steps â†’ use a claude_* block.
- For conditional logic â†’ use conditional_branch block.
- Include memory blocks when the user implies learning/remembering.

## Output Format
Return ONLY valid JSON matching the pipeline schema.
If blocks are missing, include a "missing_blocks" array in your response.
```

### 8.2 Builder Agent System Prompt

```markdown
You are the Builder Agent. You create new execution Blocks for the AgentFlow platform.

## Block Contract
Every block is a Python async function:
```python
async def execute(inputs: dict, context: dict) -> dict:
    # inputs: matches input_schema
    # context: has api_keys, user_info, etc.
    # returns: matches output_schema
```

## Available APIs
{{API_LIST_WITH_DOCS}}

## Rules
- Keep blocks FOCUSED â€” one block does ONE thing
- Always validate inputs against schema before processing
- Handle errors gracefully â€” return {"error": "message"} on failure
- Use existing libraries (requests, aiohttp, beautifulsoup4)
- Include a test case with sample input/output
- Block must be stateless â€” use memory blocks for persistence

## Output Format
Return:
1. block_definition.json (id, name, description, schemas)
2. main.py (the execution code)
3. test_case.json (sample input and expected output shape)
```

---

## 9. Pipeline Execution Engine

```python
# Simplified execution engine (hackathon version)

import asyncio
import json
from typing import Dict, Any

class PipelineExecutor:
    def __init__(self, block_registry: Dict, memory_store: Dict):
        self.blocks = block_registry
        self.memory = memory_store
        self.results = {}  # node_id -> output

    async def execute(self, pipeline: Dict) -> Dict:
        """Execute a pipeline DAG."""
        # Topological sort of nodes based on edges
        execution_order = self._topo_sort(pipeline["nodes"], pipeline["edges"])

        for node_id in execution_order:
            node = self._get_node(pipeline, node_id)
            block = self.blocks[node["block_id"]]

            # Resolve template references: {{n1.price}} â†’ actual value
            resolved_inputs = self._resolve_inputs(node["inputs"])

            # Execute the block
            try:
                output = await block.execute(resolved_inputs)
                self.results[node_id] = output
            except Exception as e:
                self.results[node_id] = {"error": str(e)}
                if pipeline.get("error_handling", {}).get("on_block_failure") == "halt":
                    break

        return self.results

    def _resolve_inputs(self, inputs: Dict) -> Dict:
        """Replace {{node_id.field}} with actual values from previous results."""
        resolved = {}
        for key, value in inputs.items():
            if isinstance(value, str) and "{{" in value:
                resolved[key] = self._resolve_template(value)
            else:
                resolved[key] = value
        return resolved

    def _resolve_template(self, template: str) -> Any:
        """Resolve {{n1.field}} or {{memory.key}} or {{user.field}}."""
        # Extract reference: n1.restaurants â†’ self.results["n1"]["restaurants"]
        # memory.past_orders â†’ self.memory["past_orders"]
        # Simple regex-based resolution
        import re
        match = re.search(r'\{\{(\w+)\.(\w+)\}\}', template)
        if match:
            source, field = match.groups()
            if source == "memory":
                return self.memory.get(field)
            elif source == "user":
                return self.user_context.get(field)
            else:
                return self.results.get(source, {}).get(field)
        return template
```

---

## 10. Data Models

### 10.1 User

```json
{
  "id": "user_123",
  "name": "John",
  "preferences": {
    "address": "123 Main St, Dublin",
    "timezone": "Europe/Dublin",
    "notification_preference": "voice",
    "budget_default_currency": "EUR"
  },
  "api_keys": {
    "stripe": "sk_...",
    "elevenlabs": "..."
  },
  "memory": {
    "food_preferences": ["spicy", "asian", "no shellfish"],
    "past_orders": [...],
    "travel_preferences": { "seat": "window", "airline_loyalty": "Ryanair" }
  }
}
```

### 10.2 Block (Registry Entry)

```json
{
  "id": "string",
  "name": "string",
  "description": "string",
  "category": "trigger | input | process | action | memory",
  "input_schema": {},
  "output_schema": {},
  "execution": {
    "runtime": "python",
    "entrypoint": "path/to/main.py",
    "function": "execute"
  },
  "metadata": {
    "created_by": "system | builder_agent",
    "apis_used": [],
    "avg_latency_ms": 0
  }
}
```

### 10.3 Pipeline

```json
{
  "id": "string",
  "user_id": "string",
  "name": "string",
  "user_prompt": "string (original request)",
  "trigger": { "type": "cron|webhook|manual|event", "config": {} },
  "nodes": [
    { "id": "n1", "block_id": "string", "inputs": {} }
  ],
  "edges": [
    { "from": "n1", "to": "n2" }
  ],
  "memory_keys": [],
  "status": "draft | active | paused | failed",
  "error_handling": {},
  "created_at": "datetime",
  "last_run": "datetime"
}
```

---

## 11. Example Walkthrough: "Monitor Amazon for PS5 below â‚¬400"

### Step 1: User types prompt

### Step 2: Orchestra decomposes
```
Capabilities needed:
1. Periodic trigger (every 6 hours)
2. Check Amazon product price
3. Compare price to threshold
4. Conditional: if below â†’ buy, else â†’ log
5. Payment processing
6. Notification
7. Price history storage
```

### Step 3: Orchestra matches blocks
```
âœ… trigger_cron          â†’ exists
âŒ amazon_price_check    â†’ NOT FOUND â†’ request Builder
âœ… filter_threshold      â†’ exists
âœ… conditional_branch    â†’ exists
âœ… payment_stripe        â†’ exists (mock for hackathon)
âœ… notify_tts            â†’ exists
âœ… memory_append         â†’ exists
```

### Step 4: Builder creates `amazon_price_check`

```python
# blocks/amazon_price_check/main.py
import aiohttp
from bs4 import BeautifulSoup

async def execute(inputs: dict, context: dict) -> dict:
    url = inputs["product_url"]
    async with aiohttp.ClientSession() as session:
        async with session.get(url, headers={"User-Agent": "..."}) as resp:
            html = await resp.text()
            soup = BeautifulSoup(html, 'html.parser')
            price_elem = soup.select_one('.a-price-whole')
            price = float(price_elem.text.replace(',', '')) if price_elem else None
            return {
                "price": price,
                "currency": "EUR",
                "in_stock": price is not None,
                "product_name": soup.select_one('#productTitle').text.strip()
            }
```

### Step 5: Orchestra builds pipeline
```
trigger_cron (6h)
    â†’ amazon_price_check
        â†’ filter_threshold (< â‚¬400)
            â†’ conditional_branch
                â”œâ”€ TRUE  â†’ payment_stripe â†’ notify_tts ("Bought it!")
                â””â”€ FALSE â†’ memory_append (price_history) â†’ notify_tts ("Still waiting")
```

### Step 6: User approves, pipeline deploys

---

## 12. Frontend Wireframe

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ðŸ§  AgentFlow                              [Settings]   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  What do you want to automate?                  â”‚    â”‚
â”‚  â”‚                                                 â”‚    â”‚
â”‚  â”‚  "Monitor Amazon for PS5 below â‚¬400 and buy it" â”‚    â”‚
â”‚  â”‚                                          [GO â†’] â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                         â”‚
â”‚  â”€â”€ Building your automation... â”€â”€                      â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  ðŸ“‹ Pipeline: PS5 Price Monitor                 â”‚    â”‚
â”‚  â”‚                                                 â”‚    â”‚
â”‚  â”‚  â° Every 6 hours                               â”‚    â”‚
â”‚  â”‚    â†“                                            â”‚    â”‚
â”‚  â”‚  ðŸ” Check Amazon Price â† [NEW BLOCK CREATED]   â”‚    â”‚
â”‚  â”‚    â†“                                            â”‚    â”‚
â”‚  â”‚  ðŸ“Š Compare: price < â‚¬400?                      â”‚    â”‚
â”‚  â”‚    â”œâ”€ YES â†’ ðŸ’³ Buy via Stripe                   â”‚    â”‚
â”‚  â”‚    â”‚         â†“                                  â”‚    â”‚
â”‚  â”‚    â”‚        ðŸ”Š "PS5 bought for â‚¬389!"           â”‚    â”‚
â”‚  â”‚    â””â”€ NO  â†’ ðŸ“ Log price                        â”‚    â”‚
â”‚  â”‚              â†“                                  â”‚    â”‚
â”‚  â”‚             ðŸ”Š "Still â‚¬450, watching..."        â”‚    â”‚
â”‚  â”‚                                                 â”‚    â”‚
â”‚  â”‚  [âœ… Approve & Start]  [âœï¸ Edit]  [âŒ Cancel]    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                         â”‚
â”‚  â”€â”€ Active Automations â”€â”€                               â”‚
â”‚  ðŸ“¦ Daily Lunch Orderer          Running since Feb 20   â”‚
â”‚  ðŸ“ˆ Bitcoin Sentiment Tracker    Last run: 2h ago       â”‚
â”‚  âœˆï¸ Flight Price Watcher         Watching...            â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 13. File Structure

```
agentflow/
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ page.tsx              # Main input + pipeline view
â”‚   â”‚   â””â”€â”€ components/
â”‚   â”‚       â”œâ”€â”€ PromptInput.tsx   # User input
â”‚   â”‚       â”œâ”€â”€ PipelineView.tsx  # Visual DAG (React Flow)
â”‚   â”‚       â”œâ”€â”€ BlockNode.tsx     # Individual block in the viz
â”‚   â”‚       â””â”€â”€ AutomationList.tsx
â”‚   â””â”€â”€ package.json
â”‚
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ main.py                   # FastAPI app
â”‚   â”œâ”€â”€ agents/
â”‚   â”‚   â”œâ”€â”€ orchestra.py          # Orchestra Agent
â”‚   â”‚   â””â”€â”€ builder.py            # Builder Agent
â”‚   â”œâ”€â”€ engine/
â”‚   â”‚   â”œâ”€â”€ executor.py           # Pipeline execution engine
â”‚   â”‚   â”œâ”€â”€ resolver.py           # Template resolver
â”‚   â”‚   â””â”€â”€ scheduler.py          # Trigger/cron management
â”‚   â”œâ”€â”€ registry/
â”‚   â”‚   â”œâ”€â”€ registry.py           # Block registry CRUD
â”‚   â”‚   â””â”€â”€ blocks.json           # Block definitions
â”‚   â”œâ”€â”€ blocks/                   # Block implementations
â”‚   â”‚   â”œâ”€â”€ web_scrape/main.py
â”‚   â”‚   â”œâ”€â”€ web_search/main.py
â”‚   â”‚   â”œâ”€â”€ claude_decide/main.py
â”‚   â”‚   â”œâ”€â”€ claude_summarize/main.py
â”‚   â”‚   â”œâ”€â”€ filter_threshold/main.py
â”‚   â”‚   â”œâ”€â”€ conditional_branch/main.py
â”‚   â”‚   â”œâ”€â”€ payment_stripe/main.py
â”‚   â”‚   â”œâ”€â”€ notify_tts/main.py
â”‚   â”‚   â”œâ”€â”€ memory_read/main.py
â”‚   â”‚   â”œâ”€â”€ memory_write/main.py
â”‚   â”‚   â””â”€â”€ memory_append/main.py
â”‚   â”œâ”€â”€ storage/
â”‚   â”‚   â”œâ”€â”€ memory.py             # User memory store
â”‚   â”‚   â””â”€â”€ pipelines.py          # Pipeline persistence
â”‚   â””â”€â”€ requirements.txt
â”‚
â”œâ”€â”€ prompts/
â”‚   â”œâ”€â”€ orchestra_system.md       # Orchestra agent system prompt
â”‚   â””â”€â”€ builder_system.md         # Builder agent system prompt
â”‚
â””â”€â”€ README.md
```

---

## 14. API Endpoints

```
POST   /api/automate          # Submit natural language request
  Body: { "prompt": "...", "user_id": "..." }
  Returns: { "pipeline": {...}, "missing_blocks": [...], "status": "ready|building" }

GET    /api/pipeline/:id      # Get pipeline status & details
PUT    /api/pipeline/:id/approve  # Approve and start pipeline
DELETE /api/pipeline/:id      # Stop and remove pipeline

GET    /api/blocks             # List all available blocks
GET    /api/blocks/:id         # Get block details
POST   /api/blocks/create      # Manually create block (via Builder)

GET    /api/runs/:pipeline_id  # Get execution history
GET    /api/memory/:user_id    # Get user memory
```

---

## 15. Key Design Decisions for Hackathon

| Decision | Choice | Why |
|----------|--------|-----|
| Block runtime | Python async | Fast to write, easy to test |
| Registry | JSON file | Zero setup, good enough for demo |
| Pipeline viz | React Flow or Mermaid | Beautiful DAG visualization fast |
| Agent comms | Direct function calls | No message queue complexity |
| Memory | In-memory dict | Persists in demo session |
| Auth | None (hardcoded user) | Saves 2+ hours |
| Payments | Mocked | Obviously |
| Real scheduling | setTimeout / manual | APScheduler if time allows |

---

## 16. What Makes This Impressive (Demo Talking Points)

1. **"I typed English, it built an automation"** â€” the core magic
2. **"It created a block that didn't exist"** â€” Builder agent in action
3. **"It remembers my preferences"** â€” memory system
4. **"I can see the whole pipeline visually"** â€” pipeline visualization
5. **"Blocks are reusable"** â€” build once, use everywhere
6. **"It works for totally different domains"** â€” shopping, research, monitoring

---

## 17. Stretch Goals (If Time Permits)

- [ ] Real ElevenLabs voice output
- [ ] Pipeline editing drag-and-drop
- [ ] Block marketplace (share blocks between users)
- [ ] Parallel block execution
- [ ] Human-in-the-loop blocks (pause pipeline, ask user, continue)
- [ ] Execution replay / debugging view
- [ ] Cost estimation per pipeline run